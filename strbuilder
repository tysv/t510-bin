#!/bin/bash

#makes X of Y
if [ "$#" -le 0 ]; then printf "%s\n" "\
------------------   strbuilder <flags> <num> <elements>   ---------------------
USAGE: 	To create strings by repeating inputs to fill full length specified.
default example: strbuilder 12 str --> 'strstrstrstr'
  strbuilder --number/-n <num>		prints str of NUM length
  strbuilder --repeat/-r <num>		prints str of NUM repetitions
  strbuilder --seperator/-s <sep_char>	seperate str elements
  strbuilder --terminate/-t <end_char>	close string with this character
     SPECIAL for -s/-t: nl = $'\n'	tab = $'\t'
  UNFLAGGED ARGS added to <str_elements> UNLESS num is currently 0"
exit 0; fi

setforecolor () {
	f_color="$(tput setaf "$1")" || { echo "error: setforecolor()"; exit 1; }
}
setbackcolor () {
	g_color="$(tput setab "$1")" || { echo "error: setbackcolor()"; exit 1; }
}

# this is not without side-effects!!
# will add some escape codes even if the change is invisible.
# only call when colors are !!already!! being introduced, or will break scripts
resetcolors () { printf "$(tput sgr0)"; }

resetpress () {
	num=0; stamp=''; seperator=''; terminator=''
	repeatflag=false; numberflag=true
}

printingpress () {
	message=''
	if [ "$repeatflag" = "true" ]; then
		length=$(($num-1))
	elif [ "$numberflag" = "true" ]; then
		length="$(( $num / ${#stamp} ))"
	fi
	count=0
	for index in $(seq 0 "$length"); do
		message+="$stamp$seperator"
		count=$((count+1))
	done
	if [ "$numberflag" = true ]; then
		remainder="$(($num % ($count * ${#stamp})))"
		message+="${stamp:$remainder}$separator"
		printf "%b" "${message:0:$remainder}$terminator"
	elif [ "$repeatflag" = "true" ]; then
		printf "%b" "$message$terminator"
	fi
}

resetpress
while [ "$#" -gt 0 ]; do

case "$1" in
	-r|--repeat)
		repeatflag="true"; numberflag="false"
	;;
	-n|--number)
		numberflag="true"; repeatflag="false"
	;;
	-s|--seperator)
		if [ "$2" = "nl" ]; then seperator+=$'\n'
		elif [ "$2" = "tab" ]; then	seperator+=$'\t'
		else seperator+="$2"; fi
		shift
	;;
	-t|--terminator)
		if [ "$2" = "nl" ]; then terminator+=$'\n'
		elif [ "$2" = "tab" ]; then	terminator+=$'\t'
		else terminator+="$2"; fi
	;;
	--)
		printingpress; resetpress
	;;
	*)
		if [ "$num" -eq 0 ] && [ "${1//[0-9]/}" = '' ]; then
			num="$1"; else stamp+="$1"; fi
	;;
esac
shift
done
# dont make none of something
if [ "$num" -lt 1 ] || [ "$stamp" = '' ]; then printf ''; exit 0; fi
printingpress

exit 0

