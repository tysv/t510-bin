#!/bin/bash

#makes X of Y

declare -A colormatch=( [red]=196 [orange]=202 [green]=2 [purple]=92 [white]=15 [black]=233	 [blue]=19 [teal]=49 [grey]=244 [gray]=244 [yellow]=226 [gold]=136
[pink]=9 )
colorkeys="${!colormatch[@]}"
colorkeys=${colorkeys//$'\n'/' '}

if [ "$#" -le 0 ]; then printf "%s\n" "\
------------------   strbuilder <flags> <num> <elements>   ---------------------
USAGE: 	To create strings by repeating inputs to fill full length specified.
default example: strbuilder 12 str --> 'strstrstrstr'
  strbuilder --colorfore/-cf <arg>	will print font in color given <0-256>
  strbuilder --colorback/-cb <arg>	will print background of font in color
  	color args can be an int 0-256, or one of limited builtin english words
  strbuilder --number/-n <num>		prints str of NUM length
  strbuilder --repeat/-r <num>		prints str of NUM repetitions
  strbuilder --seperator/-s <sep_char>	seperate str elements
  strbuilder --terminate/-t <end_char>	close string with this character
     SPECIAL for -s/-t: nl = $'\n'	tab = $'\t'
  UNFLAGGED ARGS added to <str_elements> UNLESS num is currently 0"
exit 0; fi

setforecolor () {
	color="${colormatch[$1]:-$1}"
	if [ -n "${color//[0-9]/}" ]; then 
		echo "error: setforecolor(): $color"; exit 0
	else f_color="$(tput setaf "$color")"
	fi
}
setbackcolor () {
	color="${colormatch[$1]:-$1}"
	if [ -n "${color//[0-9]/}" ]; then 
		echo "error: setbackcolor(): $color"; exit 0
	else g_color="$(tput setab "$color")"
	fi
}

# this is not without side-effects!!
# will add some escape codes even if the change is invisible.
# only call when colors are !!already!! being introduced, or will break scripts
resetcolors () { f_color=''; g_color=''; colorflag=false; tput sgr0; }

resetpress () {
	num=0; stamp=''; seperator=''; terminator=''
	repeatflag=false; numberflag=true
	if [ "$colorflag" = "true" ]; then resetcolors; fi
}

printingpress () {
	message=''
	if [ "$repeatflag" = "true" ]; then
		length=$(($num-1))
	elif [ "$numberflag" = "true" ]; then
		length="$(( $num / ${#stamp} ))"
	fi
	count=0
	for index in $(seq 0 "$length"); do
		message+="$stamp$seperator"
		count=$((count+1))
	done
	if [ "$colorflag" = true ]; then printf "${f_color}${g_color}"; fi
	if [ "$numberflag" = true ]; then
		remainder="$(($num % ($count * ${#stamp})))"
		message+="${stamp:$remainder}$separator"
		printf "%b" "${message:0:$remainder}$terminator"
	elif [ "$repeatflag" = "true" ]; then
		printf "%b" "$message$terminator"
	fi
}

resetpress
while [ "$#" -gt 0 ]; do

case "$1" in
	-cf|--colorfore)
		setforecolor "$2"; shift
		colorflag="true"
	;;
	-cb|--colorback)
		setbackcolor "$2"; shift
		colorflag="true"
	;;
	-r|--repeat)
		repeatflag="true"; numberflag="false"
	;;
	-n|--number)
		numberflag="true"; repeatflag="false"
	;;
	-s|--seperator)
		if [ "$2" = "nl" ]; then seperator+=$'\n'
		elif [ "$2" = "tab" ]; then	seperator+=$'\t'
		else seperator+="$2"; fi
		shift
	;;
	-t|--terminator)
		if [ "$2" = "nl" ]; then terminator+=$'\n'
		elif [ "$2" = "tab" ]; then	terminator+=$'\t'
		else terminator+="$2"; fi
		shift
	;;
	--)
		printingpress; resetpress
	;;
	*)
		if [ "$num" -eq 0 ] && [ "${1//[0-9]/}" = '' ]; then
			num="$1"; else stamp+="$1"; fi
	;;
esac
shift
done
# dont make none of something
if [ "$num" -lt 1 ] || [ "$stamp" = '' ]; then printf ''; exit 0; fi
printingpress

if [ "$colorflag" = true ]; then resetcolors; fi
exit 0

